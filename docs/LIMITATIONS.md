# Binary Parser 制限事項

このドキュメントでは、バイナリパーサーシステムの現在の制限事項について説明します。

## 対応している機能 ✅

以下の機能は完全に実装されています：

- **基本的な型**: stdint型（uint8_t, int8_t, uint16_t, int16_t, uint32_t, int32_t, uint64_t, int64_t）、float、double、char
- **構造体**: ネストした構造体、無名構造体
- **union**: ネストしたunion、無名union
- **配列**: 固定長の1次元配列
- **typedef**: 構造体とunionのtypedef
- **bitfield**: ビット幅の指定と値の抽出（bit_offset属性付き）
- **エンディアン**: little endian（デフォルト）とbig endianの選択可能
- **アライメント**: パック/非パックの選択可能（-pオプション）
- **#include追跡**: 複数ヘッダファイルにまたがる定義の解析

## 対応していない機能 ❌

### 1. ~~プリプロセッサマクロ~~ ✅ 対応済み！
基本的なマクロ展開に対応しました：
```c
#define BUFFER_SIZE 256
#define MAX_ITEMS 32
#define TOTAL_SIZE (BUFFER_SIZE + MAX_ITEMS)

uint8_t buffer[BUFFER_SIZE];     // ✅ 256に展開されます
uint32_t items[MAX_ITEMS];       // ✅ 32に展開されます  
uint8_t total[TOTAL_SIZE];       // ✅ 288に展開されます
```

**対応している機能**:
- 数値定数の#define
- 簡単な算術式（+, -, *, /, ()）
- マクロ参照を含む式
- 配列サイズでのマクロ使用

**まだ対応していない機能**:
- 文字列マクロ
- 関数マクロ
- 条件付きマクロ（#ifdef内での#define）
- sizeof演算子

### 2. ポインタ型
ポインタはサポートされていません：
```c
struct Node* next;      // 未対応
char* name;            // 未対応
void* data;            // 未対応
```
**回避策**: 固定サイズ配列を使用するか、データ構造を再設計してください。

### 3. 関数ポインタ
関数ポインタフィールドはサポートされていません：
```c
typedef void (*callback_t)(int);
callback_t handler;     // 未対応
```
**回避策**: シリアライズする構造体から関数ポインタを除外してください。

### 4. 多次元配列
1次元配列のみサポートされています：
```c
float matrix[4][4];     // 未対応
int cube[2][3][4];      // 未対応
```
**回避策**: 手動インデックス計算で1次元配列を使用してください。

### 5. 可変長配列メンバー（C99）
構造体末尾の可変長配列：
```c
struct Buffer {
    uint32_t size;
    uint8_t data[];     // 未対応
};
```
**回避策**: 予想される最大サイズの固定サイズ配列を使用してください。

### 6. C++の機能
C++固有の機能はサポートされていません：
- クラス
- テンプレート
- 名前空間
- メンバ関数
- アクセス修飾子（public/private）
- 継承

**回避策**: プレーンなC構造体のみを使用してください。

### 7. enum型
enumは型として認識されません：
```c
enum Status { OK, ERROR };
enum Status code;       // 認識されない
```
**回避策**: 適切な整数型（uint8_t、uint32_tなど）に置き換えてください。

### 8. 複雑なプリプロセッサディレクティブ
条件付きコンパイルは単純に無視されます：
```c
#ifdef PLATFORM_X86
    uint64_t extra_field;
#endif
```
**回避策**: 異なる設定用に個別のヘッダファイルを作成してください。

### 9. コンパイラ固有の属性
属性は無視されます：
```c
uint32_t aligned_field __attribute__((aligned(16)));
struct PackedStruct __attribute__((packed));
```
**回避策**: コマンドラインオプション（-p でパック）を使用してください。

### 10. 文字列型
null終端文字列の特別な処理はありません：
```c
char name[32];  // uint8_tの配列として扱われる
```
**回避策**: アプリケーションコードで文字列変換を処理してください。

## bitfieldの制限事項

bitfieldのメモリレイアウトはコンパイラ依存のため、以下の点に注意が必要です：

1. **ビット順序**: LSBファーストを想定
2. **パディング**: コンパイラ固有のパディングルールが適用される可能性
3. **型の混在**: 異なる基本型のbitfieldが混在する場合の動作は未定義

## ベストプラクティス

互換性を確保するために：

1. **stdint.h型のみを使用**: uint8_t、int16_t、uint32_tなど
2. **ポインタを避ける**: 代わりに固定サイズ配列を使用
3. **プリプロセッサマクロを使わない**: リテラル値を使用
4. **シンプルに保つ**: 基本的なC構造体に限定
5. **構造体をテスト**: 使用前にXML出力を確認

## 将来の改善案

潜在的な機能拡張：
- ~~基本的なマクロ展開（#define定数）~~ ✅ 実装済み
- より高度なマクロ展開（関数マクロ、sizeof）
- 基本型を設定可能なenumサポート
- 文字列型の認識
- シンプルなポインタ処理（オフセットとして）
- 多次元配列のサポート